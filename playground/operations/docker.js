"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const tslib_1=require("tslib"),command_1=require("@oclif/command"),prompts_1=tslib_1.__importDefault(require("prompts")),colors_1=tslib_1.__importDefault(require("colors")),dockerode_1=tslib_1.__importDefault(require("dockerode")),askOperation=()=>prompts_1.default({type:"autocomplete",name:"operation",message:"Select an operation",choices:[{title:"Select containers",value:"select-containers",description:"List, view & take action"},{title:"Remove all containers",value:"remove-all-containers",description:"Both running & stopped"},{title:"Get my docker info",value:"get-my-docker-info",description:"Details of running docker instance"}]},{onCancel:process.exit}),pickContaniers=e=>prompts_1.default({type:"autocompleteMultiselect",name:"selectedContainers",hint:"green names are running containers",message:"Select the containers you wanna deal with",min:1,choices:e.map(e=>({title:""+colors_1.default["running"===e.State?"green":"red"](e.Names[0]),value:e,message:"test",description:"test desc"}))},{onCancel:process.exit}),askContainersAction=()=>prompts_1.default({type:"autocomplete",name:"containerAction",message:"Select an action",choices:[{title:"Start",value:"start",description:"Start selected containers. (already running containrs will be skipped)"},{title:"Stop",value:"stop",description:"Stop selected containers. (already stopped containrs will be skipped)"},{title:"Remove",value:"remove",description:"Remove (forced) selected containers"}]},{onCancel:process.exit});class DockerTools extends command_1.Command{constructor(){super(...arguments),this.docker=new dockerode_1.default}async run(){if(!await this.getDockerInfo())return console.log(colors_1.default.red("Docker is not running."));const{operation:e}=await prompts_1.default({type:"autocomplete",name:"operation",message:"Select an operation",choices:[{title:"Select containers",value:"select-containers",description:"List, view & take action"},{title:"Remove all containers",value:"remove-all-containers",description:"Both running & stopped"},{title:"Get my docker info",value:"get-my-docker-info",description:"Details of running docker instance"}]},{onCancel:process.exit}),t=await this.docker.listContainers({all:!0});switch(e){case"select-containers":if(!t.length)return console.log(colors_1.default.red("No containers found"));const e=(await pickContaniers(t)).selectedContainers;e||(console.log(colors_1.default.red("No containers selected")),process.exit(1));const{containerAction:o}=await prompts_1.default({type:"autocomplete",name:"containerAction",message:"Select an action",choices:[{title:"Start",value:"start",description:"Start selected containers. (already running containrs will be skipped)"},{title:"Stop",value:"stop",description:"Stop selected containers. (already stopped containrs will be skipped)"},{title:"Remove",value:"remove",description:"Remove (forced) selected containers"}]},{onCancel:process.exit});this.execContainersAction(e,o);break;case"remove-all-containers":if(!t.length)return console.log(colors_1.default.red("No containers found"));await this.execContainersAction(t,"remove");break;case"get-my-docker-info":const n=await this.getDockerInfo();console.log(n)}}async execContainersAction(e,t){for(const o of e){const e=colors_1.default.cyan(`âœ… action: ${colors_1.default.bold(t)}. container: ${o.Names[0]}`);switch(t){case"remove":await this.docker.getContainer(o.Id).remove({force:!0});break;case"start":await this.docker.getContainer(o.Id).start();break;case"stop":await this.docker.getContainer(o.Id).stop();break;default:console.log(colors_1.default.red("container action not supported"))}console.log(e)}}async getDockerInfo(){return new Promise(e=>{this.docker.info().then(e).catch(()=>e(!1))})}}exports.default=DockerTools;