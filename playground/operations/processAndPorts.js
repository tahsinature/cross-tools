"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const tslib_1=require("tslib"),prompts_1=tslib_1.__importDefault(require("prompts")),fuzzy_1=tslib_1.__importDefault(require("fuzzy")),command_1=require("@oclif/command"),colors_1=tslib_1.__importDefault(require("colors")),check_1=tslib_1.__importDefault(require("./check")),http_1=tslib_1.__importDefault(require("http")),os_1=tslib_1.__importDefault(require("os")),detect_port_1=tslib_1.__importDefault(require("detect-port")),find_process_1=tslib_1.__importDefault(require("find-process")),choices=[{title:"Process Killer (By Port)",value:"kill-process-by-port",description:"Kill process by port"},{title:"Process Killer (By Pid)",value:"kill-by-pid",description:"Kill process by pid"},{title:"List Listening Ports "+colors_1.default.red("(Beta)"),value:"list-listening-port",description:"Currently works only with macOS"},{title:"Port Checker "+colors_1.default.red("(Beta)"),value:"port-check",description:"Currently works only with macOS"},{title:"Create Server",value:"start-server",description:"Listen to a port by creating a small server"}],titles=choices.map(e=>e.title),ask=async()=>prompts_1.default({type:"autocomplete",name:"operation",message:"What do you want to do?",suggest(e,t){const s=fuzzy_1.default.filter(e,titles).map(e=>e.index);return choices.filter((e,t)=>s.includes(t))},choices:choices},{onCancel:process.exit}),utils={killPid(e){const t={EINVAL:"The value of the sig argument is an invalid or unsupported signal number.",EPERM:"The process does not have permission to send the signal to any receiving process.",ESRCH:"No process or process group can be found corresponding to that specified by pid.",ERR_INVALID_ARG_TYPE:"Invalid pid"};try{process.kill(e),console.log(colors_1.default.green("Process killed"))}catch(e){console.log(colors_1.default.red(t[e.code]))}}};class ProcessAndPorts extends command_1.Command{async run(){const{operation:e}=await ask();switch(e){case"kill-process-by-port":await this.killByPort();break;case"list-listening-port":await this.listListeningPorts();break;case"start-server":await this.startServer();break;case"port-check":await check_1.default.run();break;case"kill-by-pid":await this.killByPid();break;default:console.log(colors_1.default.red("No operation selected"))}}async killByPort(){const{port:e}=await prompts_1.default({name:"port",type:"number",min:1,max:65535,message:"Please enter the port number to find the process",validate:async e=>!!(await find_process_1.default("port",e)).length||"No process found with this port"},{onCancel:process.exit}),[{cmd:t,pid:s}]=await find_process_1.default("port",e),{sure:o}=await prompts_1.default({name:"sure",type:"confirm",message:`kill ${colors_1.default.cyan(t)}?`,initial:!0},{onCancel:process.exit});o&&utils.killPid(s)}async listListeningPorts(){}async startServer(){const{port:e}=await prompts_1.default({name:"port",type:"number",min:1,max:65535,message:"Enter port that you want to listen to (1 - 65535)",validate:async e=>{if(!e)return"Please enter a port";const t=await detect_port_1.default(e);return t===e||"Port is busy or should not use, suggested: "+colors_1.default.cyan(t)}},{onCancel:process.exit}),{name:t}=await prompts_1.default({name:"name",type:"text",initial:os_1.default.userInfo().username,message:"Enter a name to say hello"},{onCancel:process.exit});this.getServer(t).listen(e,()=>{console.log(`Listening on port ${colors_1.default.green(e)}\npid: ${colors_1.default.dim(process.pid)}\n${colors_1.default.gray("http://0.0.0.0:"+e)}\n${colors_1.default.gray("http://localhost:"+e)}\n`)})}async killByPid(){const{pid:e}=await prompts_1.default({type:"number",name:"pid",message:"Type the pid you wanna kill",style:"default",min:1},{onCancel:process.exit});e||(console.log(colors_1.default.red("No pid given!")),process.exit(1)),utils.killPid(e)}getServer(e){return http_1.default.createServer((function(t,s){s.writeHead(200,{"Content-Type":"text/plain"}),s.write(`Hello ${e}!`),s.end()}))}}exports.default=ProcessAndPorts;